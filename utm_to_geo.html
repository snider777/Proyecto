<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>Conversión UTM a Geográficas con Grilla y Zona Sombreada</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

<style>
  html, body, #map {
    height: 100%;
    margin: 0; padding: 0;
    width: 100%;
  }

  #map {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    z-index: 0;
  }

  #inputPanel {
    position: absolute;
    bottom: 20px;
    right: 20px;
    background: rgba(255, 255, 255, 0.95);
    padding: 15px;
    border-radius: 8px;
    width: 320px;
    box-shadow: 0 0 15px rgba(0,0,0,0.3);
    font-family: sans-serif;
    z-index: 1000;
  }

  #inputPanel label {
    display: block;
    margin: 8px 0 4px;
    font-weight: bold;
    font-size: 0.9rem;
  }

  #inputPanel input, #inputPanel select, #inputPanel button {
    width: 100%;
    padding: 6px 8px;
    font-size: 1rem;
    border-radius: 4px;
    border: 1px solid #ccc;
    box-sizing: border-box;
  }
  
  #inputPanel button {
    margin-top: 12px;
    cursor: pointer;
    background-color: #007bff;
    color: white;
    border: none;
    transition: background-color 0.3s;
  }
  #inputPanel button:hover {
    background-color: #0056b3;
  }

  /* Carteles resultado */
  #utmInfo, #geoInfo {
    position: absolute;
    background: rgba(255, 255, 255, 0.9);
    padding: 10px 15px;
    border-radius: 8px;
    font-family: sans-serif;
    box-shadow: 0 0 10px rgba(0,0,0,0.3);
    z-index: 1001;
    font-size: 1rem;
    pointer-events: none;
    white-space: nowrap;
  }

  #utmInfo {
    top: 20px;
    left: 20px;
  }
  
  #geoInfo {
    bottom: 20px;
    left: 20px;
  }

  /* Estilo de etiquetas en la grilla */
  .grid-label {
    font-size: 11px;
    color: #555;
    pointer-events: none;
    user-select: none;
    text-shadow: 0 0 2px white;
  }
</style>

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<!-- Proj4js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
<!-- Proj4Leaflet -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4leaflet/1.0.2/proj4leaflet.js"></script>

</head>
<body>

<div id="map"></div>

<div id="inputPanel">
  <label for="zoneInput">Zona UTM (1 - 60):</label>
  <input type="number" id="zoneInput" min="1" max="60" placeholder="Ej. 14" />

  <label for="hemisferioInput">Hemisferio:</label>
  <select id="hemisferioInput">
    <option value="N" selected>Norte</option>
    <option value="S">Sur</option>
  </select>

  <label for="eastingInput">X (Easting en metros):</label>
  <input type="number" id="eastingInput" placeholder="Ej. 500000" />

  <label for="northingInput">Y (Northing en metros):</label>
  <input type="number" id="northingInput" placeholder="Ej. 4649776" />

  <button id="convertBtn">Convertir a Geográficas</button>
</div>

<div id="utmInfo" style="display:none;"></div>
<div id="geoInfo" style="display:none;"></div>

<script>
  // Crear CRS UTM específico
  function getCRSForZone(zone, hemi) {
    const southParam = hemi === "S" ? "+south" : "";
    const projString = `+proj=utm +zone=${zone} ${southParam} +ellps=WGS84 +units=m +no_defs`;
    return new L.Proj.CRS('EPSG:326' + (zone < 10 ? '0' + zone : zone) , projString, {
      resolutions: [
        8192,4096,2048,1024,512,256,128,64,32,16,8,4,2,1,0.5,0.25
      ],
      origin: [-20037508.342789244, 20037508.342789244]
    });
  }

  // Parámetros globales y variables
  let map, marker, utmGridGroup, zoneHighlightLayer;

  // Inicialización con Web Mercator para facilidad inicial
  const initialCenter = [20, -100];
  const initialZoom = 4;

  map = L.map('map').setView(initialCenter, initialZoom);

  // Capa base profesional ESRI WorldImagery
  let baseLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/' +
    'World_Imagery/MapServer/tile/{z}/{y}/{x}', {
    attribution: 'Tiles © Esri — Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
    maxZoom: 18
  }).addTo(map);

  // Validación simple
  function validateInputs(zone, hemi, x, y) {
    if (isNaN(zone) || zone<1 || zone>60) return 'Zona UTM debe estar entre 1 y 60.';
    if (hemi !== "N" && hemi !== "S") return 'Hemisferio inválido.';
    if (isNaN(x) || x < 100000 || x > 1000000) return 'X (Easting) debe estar entre 100,000 y 1,000,000 metros.';
    if (isNaN(y) || y < 0 || y > 10000000) return 'Y (Northing) inválido o fuera de rango.';
    return null;
  }

  // Crear polígono sombreado para zona UTM activa
  function createZonePolygon(zone, hemi) {
    // Limites mundiales aproximados de zonas UTM (WGS84)
    // Latitud mínima y máxima para cada hemisferio
    const lat_min = (hemi === "N") ? 0 : -80;
    const lat_max = (hemi === "N") ? 84 : 0;
    // Longitud base de la zona:
    const lon_min = (zone - 1) * 6 - 180;
    const lon_max = lon_min + 6;

    // Esquinas en LatLon (aproximadas)
    // Coordenadas: [lat, lon]
    let corners = [
      [lat_min, lon_min],
      [lat_min, lon_max],
      [lat_max, lon_max],
      [lat_max, lon_min],
      [lat_min, lon_min]
    ];

    return L.polygon(corners, {
      color: "#0055ff",
      weight: 2,
      fillColor: "#0055ff",
      fillOpacity: 0.15,
      interactive: false
    });
  }

  // Crear grilla UTM estilo estándar (líneas cada 10 km)
  function createUTMGrid(zone, hemi) {
    if (utmGridGroup) {
      map.removeLayer(utmGridGroup);
    }
    utmGridGroup = L.layerGroup();

    // Proyección UTM
    const southParam = hemi === "S" ? "+south" : "";
    const projUTM = `+proj=utm +zone=${zone} ${southParam} +ellps=WGS84 +units=m +no_defs`;
    const projWGS84 = "+proj=longlat +datum=WGS84 +no_defs";

    // Rango GRID alrededor del proveedor, ajuste para visualización
    // 100 km a cada lado (para no saturar)
    const gridSpacing = 10000; // 10km
    const gridRange = 10; // número de líneas en cada dirección

    // Función para añadir líneas con etiquetas
    function addGridLines() {
      // Bases para líneas verticales (Easting)
      for(let i = -gridRange; i <= gridRange; i++) {
        let points = [];
        for(let j = -gridRange; j <= gridRange; j++) {
          let x = 500000 + i * gridSpacing; // 500000 es centro Easting zona
          let y = j * gridSpacing;
          // Convertir UTM a latlon
          const [lon, lat] = proj4(projUTM, projWGS84, [x, y]);
          points.push([lat, lon]);
        }
        let polyline = L.polyline(points, {color:'#666', weight:1, opacity:0.5});
        utmGridGroup.addLayer(polyline);

        // Etiqueta de línea
        let labelPoint = points[Math.floor(points.length/2)];
        let label = L.marker(labelPoint, {
          icon: L.divIcon({
            className: 'grid-label',
            html: `${Math.round(500000 + i*gridSpacing)}`,
            iconSize: [0,0]
          }),
          interactive:false
        });
        utmGridGroup.addLayer(label);
      }

      // Líneas horizontales (Northing)
      for(let j = -gridRange; j <= gridRange; j++) {
        let points = [];
        for(let i = -gridRange; i <= gridRange; i++) {
          let x = 500000 + i * gridSpacing;
          let y = j * gridSpacing;
          const [lon, lat] = proj4(projUTM, projWGS84, [x, y]);
          points.push([lat, lon]);
        }
        let polyline = L.polyline(points, {color:'#666', weight:1, opacity:0.5});
        utmGridGroup.addLayer(polyline);

        // Etiqueta línea horizontal
        // Ponemos al inicio de la línea
        let labelPoint = points[0];
        let label = L.marker(labelPoint, {
          icon: L.divIcon({
            className: 'grid-label',
            html: `${Math.round(j*gridSpacing)}`,
            iconSize: [0,0]
          }),
          interactive:false
        });
        utmGridGroup.addLayer(label);
      }
    }

    addGridLines();
    utmGridGroup.addTo(map);
  }

  // Estado inicial: sin CRS cambiada ni capa zona ni grilla
  let zoneHighlightPolygon;

  // Botón convertir evento
  document.getElementById('convertBtn').addEventListener('click', () => {
    const zone = parseInt(document.getElementById('zoneInput').value);
    const hemi = document.getElementById('hemisferioInput').value;
    const x = parseFloat(document.getElementById('eastingInput').value);
    const y = parseFloat(document.getElementById('northingInput').value);

    const err = validateInputs(zone, hemi, x, y);
    if (err) {
      alert(err);
      return;
    }

    // Crear CRS para la zona
    const newCRS = getCRSForZone(zone, hemi);

    // Cambiar CRS y recargar capa base (workaround para reproyeccion)
    if(map.options.crs && map.options.crs !== newCRS){
      map.options.crs = newCRS;
      // Remove layers and add base layer again
      map.eachLayer(layer => map.removeLayer(layer));
      baseLayer.addTo(map);
    }

    // Convertir UTM a Lat/Lon
    const projUTM = `+proj=utm +zone=${zone} ${(hemi==='S')?'+south':''} +ellps=WGS84 +units=m +no_defs`;
    const projWGS84 = "+proj=longlat +datum=WGS84 +no_defs";
    const [lon, lat] = proj4(projUTM, projWGS84, [x,y]);

    // Mostrar carteles
    const utmInfoDiv = document.getElementById('utmInfo');
    utmInfoDiv.style.display = 'block';
    utmInfoDiv.innerHTML = `<b>Zona UTM:</b> ${zone} ${hemi} <br/><b>X:</b> ${x.toFixed(2)} m | <b>Y:</b> ${y.toFixed(2)} m`;

    const geoInfoDiv = document.getElementById('geoInfo');
    geoInfoDiv.style.display = 'block';
    geoInfoDiv.innerHTML = `<b>Latitud:</b> ${lat.toFixed(6)}° <br/><b>Longitud:</b> ${lon.toFixed(6)}°`;

    // Añadir o mover marcador al punto
    if(marker){
      marker.setLatLng([lat, lon]);
    }else{
      marker = L.marker([lat, lon]).addTo(map);
    }

    // Centrar y hacer zoom adecuado
    map.setView([lat, lon], 14);

    // Añadir grilla UTM visible
    createUTMGrid(zone, hemi);

    // Añadir sombra de zona UTM activa
    if(zoneHighlightPolygon){
      map.removeLayer(zoneHighlightPolygon);
    }
    zoneHighlightPolygon = createZonePolygon(zone, hemi).addTo(map);
  });
</script>

</body>
</html>
